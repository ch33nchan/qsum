## **Detailed Experiment Checklist**

### **Game Selection: Poker + Quake III Arena (OpenArena)**
- **OpenArena**: Free, open-source Quake III clone
- **ViZDoom available**: Python API for Doom/Quake environments
- **Mac compatible**: Easy install via homebrew
- **GPU optimized**: Native CUDA support for training

---

## **POKER EXPERIMENTS**

### **Implementation Checklist**

**Core QSG Framework:**
- [ ] Implement `QuantumHandRange` class with complex amplitudes
- [ ] Create `CollapseEngine` with strategic collapse selection
- [ ] Build `QuantumPolicyNetwork` with complex-valued layers
- [ ] Implement sparse superposition optimization (top-k hands only)

**Environment Setup:**
- [ ] Use PettingZoo Texas Hold'em environment
- [ ] Modify for 2-player heads-up play
- [ ] Add quantum state observation space
- [ ] Implement hand history logging

### **Experiment 1: Superposition Maintenance Analysis**

**Metrics to Track:**
- [ ] **Average Superposition Duration**: Time before collapse (seconds/hands)
- [ ] **Strategic vs Random Collapse Ratio**: Learned vs forced collapse events
- [ ] **Superposition Entropy Over Time**: Shannon entropy of hand probabilities
- [ ] **Collapse Trigger Analysis**: What opponent actions force collapse

**Data Collection:**
```python
superposition_metrics = {
    'duration_per_hand': [],
    'entropy_trajectory': [],
    'collapse_triggers': {'big_bet': 0, 'all_in': 0, 'unusual_size': 0},
    'strategic_collapse_success': []
}
```

**Required Plots:**
- [ ] Superposition duration histogram (QSG vs Classical)
- [ ] Entropy decay curves during hands
- [ ] Collapse trigger frequency heatmap
- [ ] Learning curve: superposition utilization over training episodes

### **Experiment 2: Strategic Deception Effectiveness**

**Opponent Confusion Metrics:**
- [ ] **Belief Entropy**: Opponent's uncertainty about QSG agent's hand
- [ ] **Prediction Accuracy**: How often opponent correctly predicts QSG actions
- [ ] **Adaptation Time**: Episodes needed for opponent to counter QSG strategies
- [ ] **Bluff Success Rate**: Successful deceptions vs attempts

**Implementation:**
```python
deception_metrics = {
    'opponent_belief_entropy': [],
    'prediction_accuracy': [],
    'novel_betting_patterns': set(),
    'bluff_success_rate': [],
    'opponent_confusion_index': []
}
```

**Required Plots:**
- [ ] Opponent belief entropy over game progression
- [ ] Prediction accuracy comparison (vs Classical agent)
- [ ] Novel betting pattern discovery timeline
- [ ] Confusion index heatmap across different opponent types

### **Experiment 3: Performance Benchmarks**

**Opponents to Test Against:**
- [ ] **Random Agent**: Sanity check baseline
- [ ] **Calling Station**: Always calls, never raises
- [ ] **Tight-Aggressive Bot**: Standard poker strategy
- [ ] **Classical PPO Agent**: State-of-the-art RL baseline
- [ ] **Mixed Strategy Nash**: Optimal theoretical player

**Performance Metrics:**
- [ ] **Win Rate %**: Games won out of total played
- [ ] **Big Blinds per 100 hands**: Standard poker profitability metric
- [ ] **Variance Analysis**: Consistency of performance
- [ ] **Exploitability**: How much opponent can gain by best response

**Required Plots:**
- [ ] Win rate comparison bar chart across all opponents
- [ ] BB/100 performance over training episodes
- [ ] Variance vs return scatter plot
- [ ] Exploitability radar chart

### **Experiment 4: Strategy Novelty Discovery**

**Novelty Metrics:**
- [ ] **Action Sequence Entropy**: Diversity of betting patterns
- [ ] **Classical Deviation Score**: How much strategies differ from known optimal
- [ ] **Pattern Uniqueness**: New betting sequences not in poker literature
- [ ] **Strategic Complexity**: Number of decision branches in strategy tree

**Required Plots:**
- [ ] Strategy tree visualization showing novel branches
- [ ] Action sequence frequency heatmap
- [ ] Complexity evolution over training time
- [ ] Deviation from classical strategy radar chart

---

## **OPENARENA/VIZDOOM EXPERIMENTS**

### **Implementation Checklist**

**Environment Setup:**
- [ ] Install ViZDoom via `pip install vizdoom`
- [ ] Configure basic deathmatch scenario
- [ ] Set up 1v1 combat environment
- [ ] Enable position/health/ammo tracking

**QSG Adaptation:**
- [ ] Implement `QuantumSpatialAgent` with position superposition
- [ ] Create line-of-sight observation detection
- [ ] Build spatial collapse mechanisms
- [ ] Add weapon/action superposition layers

### **Experiment 5: Spatial Superposition Advantage**

**Combat Metrics:**
- [ ] **Survival Time**: Average time alive per episode
- [ ] **Kill/Death Ratio**: Combat effectiveness measure
- [ ] **Damage Efficiency**: Damage dealt vs damage taken
- [ ] **Positional Advantage**: Time spent in tactically superior positions

**Superposition Specific:**
- [ ] **Position Uncertainty Maintenance**: Duration of spatial superposition
- [ ] **Tactical Surprise Frequency**: Successful unexpected position reveals
- [ ] **Movement Pattern Unpredictability**: Entropy of movement sequences

**Required Plots:**
- [ ] Survival time comparison across agent types
- [ ] K/D ratio improvement over training
- [ ] Position heatmap: classical vs quantum agent positioning
- [ ] Movement unpredictability over time

### **Experiment 6: Real-Time Collapse Dynamics**

**Real-Time Performance:**
- [ ] **Reaction Time Analysis**: Time from observation to collapse
- [ ] **Superposition Under Pressure**: Maintenance during combat
- [ ] **Decision Speed**: Actions per second comparison
- [ ] **Tactical Flexibility**: Adaptation to changing combat situations

**Required Plots:**
- [ ] Reaction time distribution histograms
- [ ] Superposition duration under different stress levels
- [ ] Performance degradation under time pressure
- [ ] Tactical adaptation timeline during combat

### **Experiment 7: Cross-Domain Transfer**

**Transfer Learning Metrics:**
- [ ] **Strategy Pattern Similarity**: Common superposition patterns between domains
- [ ] **Learning Speed**: Training time for domain adaptation
- [ ] **Performance Retention**: Skill maintenance across domains
- [ ] **Collapse Mechanism Generalization**: Similar triggers across games

**Required Plots:**
- [ ] Strategy similarity matrix between poker and arena combat
- [ ] Transfer learning curves
- [ ] Performance comparison: scratch training vs transfer
- [ ] Collapse pattern correlation analysis

---

## **COMPUTATIONAL ANALYSIS**

### **Efficiency Benchmarks**

**Training Metrics:**
- [ ] **GPU Utilization**: Memory and compute usage
- [ ] **Training Time**: Episodes per hour
- [ ] **Convergence Speed**: Episodes to reach performance threshold
- [ ] **Memory Scaling**: RAM usage vs superposition complexity

**Inference Metrics:**
- [ ] **Decision Time**: Milliseconds per action
- [ ] **Superposition Processing**: Complex computation overhead
- [ ] **Real-time Viability**: Can run at game speed (60+ FPS)

**Required Plots:**
- [ ] Training efficiency comparison (QSG vs Classical)
- [ ] Memory usage scaling with superposition size
- [ ] Inference speed vs accuracy tradeoff
- [ ] GPU utilization timeline during training

---

## **STATISTICAL VALIDATION**

### **Statistical Tests Checklist**

**Significance Testing:**
- [ ] **Paired t-tests**: Performance differences between agents
- [ ] **Mann-Whitney U**: Non-parametric performance comparisons
- [ ] **Bootstrap Confidence Intervals**: Robust performance estimates
- [ ] **Effect Size Calculations**: Practical significance measurement

**Reproducibility:**
- [ ] **Multiple Random Seeds**: 5+ different initializations
- [ ] **Cross-Validation**: K-fold validation of results
- [ ] **Stability Analysis**: Performance variance across runs
- [ ] **Hyperparameter Sensitivity**: Robustness to parameter changes

---

## **VISUALIZATION REQUIREMENTS**

### **Essential Plots for Paper**

**Performance Visualizations:**
- [ ] Win rate comparison bar charts with error bars
- [ ] Learning curves with confidence intervals
- [ ] Performance vs computational cost scatter plots
- [ ] Strategy evolution timeline plots

**Behavioral Visualizations:**
- [ ] Superposition state evolution animations
- [ ] Decision tree diagrams showing quantum branches
- [ ] Heatmaps of position/action probabilities
- [ ] Network architecture diagrams

**Analysis Visualizations:**
- [ ] Statistical significance forest plots
- [ ] Correlation matrices between metrics
- [ ] Principal component analysis of strategies
- [ ] Cluster analysis of emergent behaviors

---

## **SUCCESS CRITERIA CHECKLIST**

### **Minimum Viable Results**
- [ ] QSG outperforms random baseline in both domains (p < 0.05)
- [ ] Measurable superposition maintenance > 0 duration
- [ ] At least 3 documented novel strategy patterns
- [ ] Computational overhead < 3x classical approaches

### **Strong Results**
- [ ] 15%+ performance improvement vs classical RL (p < 0.01)
- [ ] Clear opponent confusion evidence (entropy increase)
- [ ] Successful cross-domain strategy transfer
- [ ] Real-time performance viable (>30 FPS)

### **Breakthrough Results**
- [ ] Novel strategies recognized as genuinely new by domain experts
- [ ] Computational efficiency competitive with state-of-the-art
- [ ] Clear mathematical explanation for quantum advantage
- [ ] Reproducible results across multiple environments

**Total Estimated Runtime**: ~72-96 GPU hours for complete experimental suite

This checklist provides concrete, measurable experiments that will definitively validate (or refute) the QSG concept across two very different domains while maintaining scientific rigor.